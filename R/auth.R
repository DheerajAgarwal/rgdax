#' Parse Authenticated Calls To COINBASE PRO (erstwhile GDAX) API
#'
#'
#' @name auth
#'
#' @description This is an internal function that will be used for all private connections to the user account. This function determines the kind of API call (GET / POST / DELETE).
#'
#' @param method Mandatory character value. Value must be upper case.
#' @param req.url THE URL component for the API. Default to "/accounts".
#' @param api.key Mandatory character value. This is the API key as generated by GDAX. Typically a 32 character value.
#' @param secret Mandatory character value. This is the API secret as generated by GDAX. Typically a 88 character value.
#' @param passphrase Mandatory character value. This is the pass-phrase as generated by GDAX. Typically a 11 character value.
#' @param order Optional named list. If method is \code{POST} then the field is required for post to work, else the api end point will return an error.
#' @param envir Optional environment selector. If envir is `prod` then it will connect to the prod environment, else it will connect to the sandbox environment.
#'
#' @return  A named list of server response.
#'
#' @import digest
#' @import httr
#' @import plyr


# function definition ----
auth <- function(method,
                 req.url = "/accounts/",
                 api.key,
                 secret,
                 passphrase,
                 order = NULL,
                 envir = "prod") {
  #define api base url----
  if (envir == "prod") {
    api.url <- "https://api.exchange.coinbase.com"
  } else {
    api.url <- "https://api-public.sandbox.exchange.coinbase.com"
  }

  #generate nonce and key encodings----
  url <- paste0(api.url, req.url)
  timestamp <-
    format(as.numeric(Sys.time()), digits = 13) # create nonce
  key <- base64Decode(secret, mode = "raw") # encode api secret

  #create final end point----
  if (method == "GET" | method == "DELETE") {
    what <- paste0(timestamp, method, req.url) # get method
  } else if (method == "POST") {
    what <- paste0(timestamp, method, req.url, order)
  } else {
    print("Undefined Method")
  }

  #create encoded signature----
  sign <-
    base64Encode(hmac(key, what, algo = "sha256", raw = TRUE)) # hash

  #define headers----
  httpheader <- c(
    'CB-ACCESS-KEY' = api.key,
    'CB-ACCESS-SIGN' = sign,
    'CB-ACCESS-TIMESTAMP' = timestamp,
    'CB-ACCESS-PASSPHRASE' = passphrase,
    'Content-Type' = 'application/json'
  )

  # Generating GET results----
  if (method == "GET") {
      response <- httr::content(httr::GET(url, add_headers(httpheader)))
  }

  # Generating POST results----
  else if (method == "POST") {
      response <- httr::content(httr::POST(url, add_headers(httpheader), body = order))
  }

  # Generating DELETE results----
  else if (method == "DELETE") {
      response <- httr::content(httr::DELETE(url, add_headers(httpheader)))
  }

  # Return----
  return(response)
}
